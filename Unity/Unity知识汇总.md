# Unity知识汇总

## 1. 渲染管道

Rendering(渲染): 将三维物体或三维场景的描述转化为一幅二维图像，生成的二维图像能很好的反应三维物体或三维场景。 计算机根据模型(model)创建图像的过程

渲染管道: 指为了在显示器上显示图像而经过的一系列必要操作

主要步骤:

1. 应用程序准备数据(顶点坐标、法向量、纹理、纹理坐标)传给图形处理器
1. 顶点变换(Vertex Transformation): 顶点变换在每个顶点上执行一系列的数学操作。这些操作包括把顶点位置变换到屏幕位置以便光栅器使用，为贴图产生纹理坐标，以及照亮顶点以决定它的颜色
    - 物体空间-(建模变换)->世界空间-(视变换)->视图空间-(可视空间)->裁剪空间-(裁剪、映射)->视口空间-(视图变换)->屏幕空间
1. 图元装配和图元处理: 根据顶点的原始连接关系还原出网格结构
    - 在这个阶段顶点将会根据应用程序送往的图元规则如GL_POINTS、GL_TRIANGLES 等将会被组装成图元
    - 这些图元需要经过裁剪到可视平截体（三维空间中一个可见的区域）和任何有效地应用程序指定的裁剪平面
1. 光栅化(Rasterization): 光栅化是一个决定哪些像素被几何图元覆盖的过程。多边形、线段和点根据为每种图元指定的规则分别被光栅化
    - 将顶点和图元对应到像素
    - 计算每个独立像素点的颜色值
    - 当一个图元被光栅化为一堆零个或多个片段的时候，插值、贴图和着色阶段就在片段属性需要的时候插值，执行一系列的贴图和数学操作，然后为每个片段确定一个最终的颜色
1. 光栅操作(Raster Operations): 在这个阶段，隐藏面通过一个被称为深度测试的过程而消除。其它一些效果，例如混合和基于模板的阴影也发生在这个阶段
    - 消除遮挡面
    - 纹理操作，根据像素的纹理坐标，查询对应的纹理值
    - Blending，通常称为alpha blending，根据目前已经画好的颜色，与正在计算的颜色的alpha值混合，形成新的颜色
    - Filtering，将正在计算的颜色经过某种滤镜后输出

### Shader (着色器)

- Shader 是一种较为短小的程序片段，用于告诉图形硬件如何计算和输出图像
- Shader是可编程图形管线的算法片段

Shader（着色器）实际上就是一小段程序，它负责将输入的顶点数据以指定的方式和输入的贴图或者颜色等组合起来，然后输出。绘图单元可以依据这个输出来将图像绘制到屏幕上。输入的贴图或者颜色等，加上对应的Shader，以及对Shader的特定的参数设置，将这些内容（Shader及输入参数）打包存储在一起，得到的就是一个Material（材质），之后，我们便可以将材质赋予三维物体来进行渲染（输出）了。

材质好比引擎最终使用的商品，Shader好比是生产这种商品的加工方法，而贴图就是原材料

## 2. 协同程序

在主线程运行的同时开启另一段逻辑处理程序，来协助当前程序的运行。一般会在所有update之后调用，遇到yield return 后退出，等条件满足后继续执行

## 3. Unity游戏性能优化

### 1. CPU优化

- 缓存重要对象的引用：脚本中使用GameObject.Find这类函数获取游戏对象，使用GetComponent这类函数以及transform这类内置访问器获取组件，会产生较多开销。所以在Start或Awake里获取一次组件的引用，把引用缓存在当前class的字段中，可以减少开销
- 删除空的回调函数。空的回调函数也会消耗CPU时间，应当删除而不是留空
- 使用对象池Objects Pool：频繁创建和销毁游戏对象会为脚本执行和垃圾回收带来很大的性能开销
  - 创建一个数组或链表，作为对象池。实例一组对象，设置为未激活状态，放入对象池中
  - 创建对象时从对象池中取出一个未激活对象，激活该对象，设置相关属性，然后直接使用
  - 销毁对象时禁用该对象，然后放回对象池即可
- 避免集中实例化对象造成CPU峰值：可以使用协程函数以一定时间间隔创建多个游戏对象
- 优化渲染系统：
    - 减少模型的顶点个数和面片个数
    - 合并物体，或者使用相同的材质
    - 减少粒子系统的使用，或者降低粒子的发射速度
    - 关闭远处的粒子系统
- 优化物理系统：
    - 设置Fixed Timestep(>=16ms for 60FPS)和Maximum Allowed Timestep(8*16=130-160ms for 60FPS)，调节物理系统的计算时间间隔
    - 避免使用MeshCollider、Wheel Collider
- 合理进行垃圾回收
    - 及时调用Destroy函数释放不用的资源
    - 按照一定频率手动进行垃圾回收：System.GC.Collect();
    - 选择合适的垃圾回收点

### 2. 渲染优化

提高渲染效率(帧率)，保证渲染质量

- 控制渲染的顶点个数(PC游戏每帧渲染的顶点数量不宜超过几百万个，移动端不宜超过十万个)
  - 减小摄像机对象的远平面的距离 (Clipping Planes - Far)
  - 减小摄像机对象的视角 (Field of View)
  - 降低物体摆放的密集程度
- 使用遮挡剔除技术 (Occlusion Culling)：剔除摄像机视域内被遮挡的物体，提高渲染效率
- LOD技术 (Level of Details)：为同一个物体准备多个精度不同的模型，如果物体距离摄像机较近，使用高精度模型绘制物体，展现细节。如果较远，使用低精度模型绘制物体，提高渲染效率
- 减少Pixel Light的使用，不要将光源的Render Mode设为Important
- 使用全局光照+光照探头替代实时局部光照：更好的光影效果，更高的渲染效率
- 避免使用实时阴影：可以用Projector组件模拟
- 为纹理启用Mip Maps：提高渲染速度和渲染效果，增加内存消耗

### 3. 内存优化

- 降低资源的大小
  - 导入时压缩资源
  - 使用压缩纹理：如为安卓平台的纹理设置ETC1纹理压缩格式
  - 使用压缩的音频：使用MP3保存背景音乐，使用WAV保存音效
  - 调整光照贴图的大小
- 及时释放不用的资源
  - 及时调用Destory函数
  - 定期调用GC.Collect函数，手动进行垃圾回收

### Unity性能分析工具Profiler

## 4. 动态加载资源方式

## 5. 实现2D游戏方式

## 6. 光照

### **4种光源类型：**

#### 1. 点光源 (Point Light)

- 从光源位置向所有方向发射强度相等的光线
- 光线强度不断衰减，到达预设的极限距离range时，衰减为0
- 适合模拟灯笼、火把等局部光源

#### 2. 方向光 (Directional Light)

- 不会衰减，它以相同的强度和方向照亮空间中的所有物体
- 位置信息没有任何意义
- 模拟日光、月光

#### 3. 聚光灯 (Spot Light)

- 从光源位置向某个特定位置照射，照亮一个圆锥体的空间区域，传播过程中不断衰减
- 模拟人造光源，如手电，车灯

#### 4. 面光源 (Area Light)

- 使用一个矩形来定义，光线从矩形的证明出发，照亮矩形前的一片区域
- 适用于模拟广告灯箱等光源
- **不能作为实时光源**

### **阴影缺失的原因**

- 显卡过于古老，不支持阴影渲染
- 项目质量(Quality)设置中关闭了阴影
- 产生阴影的光源Rendering Mode为Auto，但是被Unity自动判断为非Important类型的光源
- 产生阴影的物体是透明物体
- 接收阴影的物体使用了Standard Shader，并且Rendering Mode为Transparent
- 接收阴影的物体使用了其它逐顶点的着色器

### **光照模型**

#### 1. 局部光照 (Local illumination)

- 计算物体光照时不考虑物体之间的相互影响，只考虑一个光源、一个物体表面、一个观察者
- 简单、快速，与真实世界差异较大

#### 2. 全局光照 (Global illumination)

- 计算物体光照时，既考虑直接光照，也考虑间接光照，也就是物体之间的反射光线和折射光线产生的影响
- 效果接近真实
- 算法复杂，计算量大
- 难以实时计算

##### Unity全局光照 - Baked GI

- 需要预计算(烘焙)，只对静态物体有效
- 编辑阶段：
  - 标记出场景中不会运动的静态物体
  - 烘焙：预先计算静态物体的全局光照
  - 结果保存为光照纹理Lightmap
- 游戏运行阶段：
    - 直接从Lightmap中获取光照信息

##### Unity全局光照 - Precomputedd Realtime GI

- Unity5.0之后的版本支持预计算实时GI
- 需要烘焙，只对静态物体有效
- 运行时实时计算全局光照
- 可以在运行时动态改变光源的数量，位置，朝向以及物体的材质

#### 3. Unity全局光照的局限性

- 需花费较长时间预计算
- 只对静态物体有效
- 非静态物体反射的光线无法影响其它物体
- 非静态物体也无法直接受到烘焙光源和静态物体反射光线的影响

#### 4. Unity光照探头 Light Probes

- Light Probes技术用于解决全局光照模式下，非静态物体与静态场景之间光照不协调问题
- 基本思想：
  - 编辑阶段：在场景中放置光照探头，在探头位置对光照信息进行采样，然后保存采样数据
  - 运行阶段：选择非静态物体附件的几个光照探头，使用这些探头的采样数据，插值获得静态物体应当受到的光照

### Unity图像特效 (Image Effect)

Image Effect对游戏渲染出的画面进行后期处理，可以为游戏带来丰富的视觉特效

## 8. 生命周期

[Unity脚本生命周期图](https://docs.unity3d.com/Manual/ExecutionOrder.html)

## 9. Camera相关选项

Clear Flags 清除标记

- Skybox 天空盒: 这是默认设置。在屏幕上空的部分将显示当前相机的天空盒
- Solid Color 纯色: 屏幕上的任何空的部分将显示当前相机的背景颜色
- Depth Only 仅深度: 摄像机Depth属性设置相机绘图顺序，具有较大值的相机将被绘制在具有较小值的相机的上面
- Don't Clear 不清除: 该模式不清除任何颜色或深度缓存。其结果是，每帧绘制在下一帧之上，造成涂片效果

Culling Mask 剔除遮罩

- 剔除遮罩使用Layer有选择地渲染一组对象

## 10. 渲染队列

## 11. NGUI知识点

## 12. DrawCall

- Unity准备渲染数据，通知GPU进行渲染的过程叫作一次Draw Call
- 一个Draw Call通常只绘制一个物体，每次Draw Call都需准备Shader和材质，比较耗时
- Draw Call合并技术把具有相同材质的多个物体合并为一个物体，在一个Draw Call中完成绘制，从而提高性能
  - 动态合并：允许物体自由移动和旋转，且不需要做额外配置。但对物体的定点数和缩放情况有所要求。在材质相同的情况下系统会自动进行动态合并
  - 静态合并：以最大化方式实现Draw Call合并，但只对静态物体有效，需要在编辑阶段进行一些配置

## 13. 四元数